// Universal Parameter Parser - Phase 1
// Extracts and manages parameters across URL, headers, and request body

export interface ParameterConfig {
  name: string
  value: string
  autoGenerated: boolean
  pattern: string
  sources: Array<'url' | 'headers' | 'body'>
}

export interface EndpointParameters {
  // All unique parameters found across URL, headers, body
  parameters: Record<string, ParameterConfig>
  
  // Source tracking for UI display
  sources: {
    url: string[]      // [userId, postId] 
    headers: string[]  // [authToken, timestamp]
    body: string[]     // [userId, orderId, createdDate]
  }
  
  // Totals for compact display
  totalCount: number
}

// Pattern detection rules for smart default generation
const PARAMETER_PATTERNS = {
  // IDs - incremental numbers
  id: /.*[Ii]d$/,                           // petId, userId ‚Üí 123, 456
  
  // UUIDs  
  uuid: /.*([Uu]id|[Uu]uid)$/,             // petUuid, userUid ‚Üí uuid
  
  // Timestamps
  timestamp: /.*([Tt]m|[Tt]imestamp)$/,     // createdTm ‚Üí 1640995200
  
  // Dates
  date: /.*[Dd]ate$/,                       // orderDate ‚Üí "2024-01-15"
  
  // Times  
  time: /.*[Tt]ime$/,                       // startTime ‚Üí "14:30:00"
  
  // Tokens
  token: /.*([Tt]oken|[Kk]ey)$/,           // authToken, apiKey ‚Üí "abc123"
  
  // Names/Strings
  string: /.*([Nn]ame|[Tt]itle|[Tt]ext)$/  // userName, pageTitle ‚Üí "example"
}

// Smart default value generators
const generateDefaultValue = (paramName: string, pattern: string): string => {
  // Remove braces if present
  const cleanName = paramName.replace(/[{}]/g, '')
  
  switch (pattern) {
    case 'id':
      // Generate incremental IDs based on parameter name
      const idCounters: Record<string, number> = {}
      const baseId = idCounters[cleanName] || Math.floor(Math.random() * 900) + 100
      idCounters[cleanName] = baseId + 1
      return baseId.toString()
      
    case 'uuid':
      // Generate a simple UUID-like string
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0
        const v = c === 'x' ? r : (r & 0x3 | 0x8)
        return v.toString(16)
      })
      
    case 'timestamp':
      // Current timestamp
      return Date.now().toString()
      
    case 'date':
      // Today's date in YYYY-MM-DD format
      return new Date().toISOString().split('T')[0]
      
    case 'time':
      // Current time in HH:MM:SS format
      return new Date().toISOString().split('T')[1].split('.')[0]
      
    case 'token':
      // Generate a simple token-like string
      return 'tk_' + Math.random().toString(36).substring(2, 15)
      
    case 'string':
      // Generate a meaningful string based on parameter name
      return `example_${cleanName.toLowerCase().replace(/[^a-z0-9]/g, '_')}`
      
    default:
      // Generic fallback
      return `${cleanName}_value`
  }
}

// Detect parameter pattern based on name
const detectPattern = (paramName: string): string => {
  const cleanName = paramName.replace(/[{}]/g, '')
  
  for (const [pattern, regex] of Object.entries(PARAMETER_PATTERNS)) {
    if (regex.test(cleanName)) {
      return pattern
    }
  }
  
  return 'default'
}

// Extract parameters from URL
export const extractParametersFromURL = (url: string): string[] => {
  if (!url) return []
  
  const matches = url.match(/\{([^}]+)\}/g)
  return matches ? matches.map(match => match.slice(1, -1)) : []
}

// Extract parameters from headers object
export const extractParametersFromHeaders = (headers?: Record<string, string>): string[] => {
  if (!headers) return []
  
  const parameters: string[] = []
  
  for (const [key, value] of Object.entries(headers)) {
    if (typeof value === 'string') {
      const matches = value.match(/\{([^}]+)\}/g)
      if (matches) {
        parameters.push(...matches.map(match => match.slice(1, -1)))
      }
    }
  }
  
  return parameters
}

// Extract parameters from request body (supports nested objects)
export const extractParametersFromBody = (body?: any): string[] => {
  if (!body) return []
  
  const parameters: string[] = []
  
  const extractFromValue = (value: any): void => {
    if (typeof value === 'string') {
      const matches = value.match(/\{([^}]+)\}/g)
      if (matches) {
        parameters.push(...matches.map(match => match.slice(1, -1)))
      }
    } else if (typeof value === 'object' && value !== null) {
      for (const nestedValue of Object.values(value)) {
        extractFromValue(nestedValue)
      }
    }
  }
  
  // Handle string body (JSON string) or object body
  if (typeof body === 'string') {
    try {
      const parsed = JSON.parse(body)
      extractFromValue(parsed)
    } catch {
      // If not valid JSON, treat as string
      extractFromValue(body)
    }
  } else {
    extractFromValue(body)
  }
  
  return parameters
}

// Main function: Parse all parameters from an endpoint
export const parseEndpointParameters = (endpoint: {
  url: string
  headers?: Record<string, string>
  body?: any
}): EndpointParameters => {
  // Extract parameters from each source
  const urlParams = extractParametersFromURL(endpoint.url)
  const headerParams = extractParametersFromHeaders(endpoint.headers)
  const bodyParams = extractParametersFromBody(endpoint.body)
  
  // Collect all unique parameter names
  const allParamNames = [...new Set([...urlParams, ...headerParams, ...bodyParams])]
  
  // Create parameter configurations with smart defaults
  const parameters: Record<string, ParameterConfig> = {}
  
  for (const paramName of allParamNames) {
    const pattern = detectPattern(paramName)
    const sources: Array<'url' | 'headers' | 'body'> = []
    
    if (urlParams.includes(paramName)) sources.push('url')
    if (headerParams.includes(paramName)) sources.push('headers')
    if (bodyParams.includes(paramName)) sources.push('body')
    
    parameters[paramName] = {
      name: paramName,
      value: generateDefaultValue(paramName, pattern),
      autoGenerated: true,
      pattern,
      sources
    }
  }
  
  return {
    parameters,
    sources: {
      url: urlParams,
      headers: headerParams,
      body: bodyParams
    },
    totalCount: allParamNames.length
  }
}

// Utility: Get parameter summary for UI display
export const getParameterSummary = (endpointParams: EndpointParameters): string => {
  const { sources, totalCount } = endpointParams
  
  if (totalCount === 0) return 'No parameters'
  
  const parts: string[] = []
  if (sources.url.length > 0) parts.push(`URL: ${sources.url.length}`)
  if (sources.headers.length > 0) parts.push(`Headers: ${sources.headers.length}`)
  if (sources.body.length > 0) parts.push(`Body: ${sources.body.length}`)
  
  return `${totalCount} total (${parts.join(', ')})`
}

// Debug utility: Log parameter analysis
export const debugParameters = (endpoint: { url: string, headers?: Record<string, string>, body?: any }) => {
  const params = parseEndpointParameters(endpoint)
  
  console.log('üîç Parameter Analysis:', {
    endpoint: {
      url: endpoint.url,
      headers: endpoint.headers,
      body: endpoint.body
    },
    analysis: params,
    summary: getParameterSummary(params)
  })
  
  return params
}